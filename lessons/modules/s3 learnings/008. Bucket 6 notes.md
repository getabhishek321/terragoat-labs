# Bucket: `aws_s3_bucket.logs`

##  Purpose

The `logs` bucket is designed to store **S3 access logs** and potentially logs from other AWS services.
It serves as the **central audit bucket** in this module.

Unlike the previous buckets, this one is intentionally **properly secured** to showcase:

* what *good* configuration looks like
* how a log storage bucket should be designed in real-world architectures
* the benchmark against which you evaluate misconfigured buckets

---

##  Terraform Definition (Simplified)

```hcl
resource "aws_s3_bucket" "logs" {
  bucket = "${local.resource_prefix.value}-logs"
  acl    = "log-delivery-write"

  versioning {
    enabled = true
  }

  server_side_encryption_configuration {
    rule {
      apply_server_side_encryption_by_default {
        sse_algorithm     = "aws:kms"
        kms_master_key_id = "${aws_kms_key.logs_key.arn}"
      }
    }
  }

  force_destroy = true
  tags          = merge(...)
}
```

---

#  Deep Dive Into Configuration

## **1. ACL: `log-delivery-write`**

```hcl
acl = "log-delivery-write"
```

This ACL is specifically designed for logging buckets.

It grants:

* The **S3 logging service principal** permission to write log files
* No public access
* No general read/write access

### Why this matters:

* Logging services require write permissions
* But you do *not* want to open additional access
* Prevents accidental or malicious public exposure

This is a proper production-level ACL for a log bucket.

---

## **2. ✔ Versioning Enabled**

```hcl
versioning {
  enabled = true
}
```

Versioning in a log bucket provides:

* Historical log retention
* Forensic value (old logs preserved)
* Protection from tampering or accidental deletes

If an attacker deletes logs:

* Only the *current version* is removed
* Previous versions remain

This is essential for **tamper resistance in DFIR**.

---

## **3. ✔ Server-Side Encryption (SSE-KMS)**

```hcl
server_side_encryption_configuration {
  rule {
    apply_server_side_encryption_by_default {
      sse_algorithm     = "aws:kms"
      kms_master_key_id = aws_kms_key.logs_key.arn
    }
  }
}
```

This is the most secure configuration seen so far.

### Key points:

### ** Encryption Algorithm: `aws:kms`**

* Uses **KMS-managed keys** (not default S3 AES-256)
* Enables fine-grained control over:

  * who can decrypt logs
  * how logs are accessed
  * logging of KMS decrypt operations

### ** Custom KMS Key**

```hcl
kms_master_key_id = aws_kms_key.logs_key.arn
```

Advantages:

* Can restrict which IAM roles can read audit logs
* Often logs are “read-only for security teams only”
* Prevents wide access by application or developer roles

This is *exactly* what you want for audit log storage.

---

## **4. `force_destroy = true` — Still dangerous even here**

It remains:

```hcl
force_destroy = true
```

While it makes sense in a lab:

> In production, you **never** set `force_destroy` on log buckets.

Why?

* Logs are compliance evidence
* Must be preserved even if a Terraform config changes
* Force destroy → wipes all logs + history

However, TerraformGoat is a **training environment**, so this is acceptable.

---

# ✔ Complete Security Posture (This is the Gold Standard)

| Control        | Status    | Notes                                                 |
| -------------- | --------- | ----------------------------------------------------- |
| Public Access  | ❌ No      | Bucket is private                                     |
| ACL            | ✔ Correct | Uses `log-delivery-write`                             |
| Versioning     | ✔ Enabled | Protects audit trails                                 |
| Encryption     | ✔ SSE-KMS | Uses CMK for maximum security                         |
| Access Logging | N/A       | This bucket *receives* logs, doesn’t need logs itself |
| force_destroy  | ⚠️ Risky  | Lab-only convenience                                  |

This bucket represents a **properly hardened, audit-ready S3 bucket**.

---

#  Learning Takeaway

The `logs` bucket is the **reference architecture** for secure S3 design:

### Secure-by-default patterns visible here:

* Minimal permissions (`log-delivery-write`)
* Mandatory encryption (KMS)
* Versioning enabled
* Clear separation of concerns (dedicated log bucket)
* Immutable(ish) bucket design using versioning + restricted ACLs

When doing IaC reviews or designing secure cloud storage, this is the posture you aim for.

In TerraformGoat:

> Every other bucket is intentionally flawed so you can compare it to this one and learn what “best practice” looks like.

---

If you want, I can now generate:

### ✅ A combined summary table

### ✅ A security comparison matrix

### ✅ A "How to Fix Each Bucket" section

### ✅ A “Secure Version of this Entire File” rewrite

### ✅ Checkov-style findings for each bucket

### ✅ GitHub README structure for your repo

Just tell me:

> **Give me the consolidated summary**
> or
> **Give me the secure rewrite**
> or
> **Move to the next Terraform file**
